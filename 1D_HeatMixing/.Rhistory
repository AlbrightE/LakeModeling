x = (dt/86400) / icep
iceT = iceT * (1 - x) + u[1] * x
if ((iceT <= 0) == TRUE){
# if (any(u <= 0) == TRUE){
supercooled <- which(u < 0)
initEnergy <- sum((0-u[supercooled])*hyps$Area_meterSquared[supercooled] * dx * 4.18E6)
if (ice != TRUE) {
Hi <- Ice_min+(initEnergy/(910*333500))/max(hyps$Area_meterSquared)
} else {
if (Tair(n*dt) > 0){
Tice <- 0
Hi = Hi -max(c(0, meltP * dt*((absorp*Jsw(n * dt))+(longwave(cc = CC(n * dt), sigma = sigma, Tair = Tair(n * dt), ea = ea(n * dt), emissivity = emissivity, Jlw = Jlw(n * dt)) +
backscattering(emissivity = emissivity, sigma = sigma, Twater = un[1]) +
latent(Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n *dt), p2 = p2, pa = Pa(n*dt), ea=ea(n*dt),  RH = RH(n * dt)) +
sensible(p2 = p2, B = B, Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n * dt))) )/(1000*333500)))
} else {
Tice <-  ((1/(10 * Hi)) * 0 +  Tair(n*dt)) / (1 + (1/(10 * Hi)))
Hi <- min(Ice_min, sqrt(Hi**2 + 2 * 2.1/(910 * 333500)* (0 - Tice) * dt))
}
}
ice = TRUE
if (Hi > 0){
u[supercooled] = 0
u[1] = 0
}
Him[n] <- Hi
} else if (ice == TRUE & Hi > 0) {
if (Tair(n*dt) > 0){
Tice <- 0
Hi = Hi -max(c(0, meltP * dt*((absorp*Jsw(n * dt))+(backscattering(emissivity = emissivity, sigma = sigma, Twater = un[1]) +
latent(Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n *dt), p2 = p2, pa = Pa(n*dt), ea=ea(n*dt),  RH = RH(n * dt)) +
sensible(p2 = p2, B = B, Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n * dt))) )/(1000*333500)))
} else {
Tice <-  ((1/(10 * Hi)) * 0 +  Tair(n*dt)) / (1 + (1/(10 * Hi)))
Hi <- min(Ice_min, sqrt(Hi**2 + 2 * 2.1/(910 * 333500)* (0 - Tice) * dt))
}
u[supercooled] = 0
u[1] = 0
Him[n] <- Hi
} else if (ice == TRUE & Hi <= 0){
ice = FALSE
}
n2m[, n] <- n2
um[, n] <- u
lines( u, seq(0, dx * nx, length.out=(nx)),
ylim = rev(range(seq(0, dx * nx, length.out=(nx)))), lty = 'dashed');
# print(un)
# print(u)
# cat ("Press [enter] to continue")
# line <- readline()
}
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
str(um)
## water temperature time series at different depths
plot(seq(1, ncol(um))*dt/24/3600, um[1,], col = 'red', type = 'l',
xlab = 'Time (d)', ylab='Temperature (degC)', ylim=c(-1,35), lwd = 2)
for (i in 2:nx){
lines(seq(1, ncol(um))*dt/24/3600, um[i,], col = sample(col_vector,1),
lty = 'dashed',lwd =2)
}
# ice thickness (direct model output)
plot(seq(1, ncol(um))*dt/24/3600, Him, type = 'l',
col = 'red', xlab = 'Time',
ylab= 'Ice thickness (m)', lwd= 3)
## surface mixed layer depth (direct model output)
therm.z.roll = zoo::rollmean(therm.z, 14)
plot(seq(1, ncol(um))*dt/24/3600, therm.z, type = 'l',ylim = rev(range( seq(0,zmax, length.out=nx))),
col = 'red', xlab = 'Time',
ylab= 'Mixed Layer Depth (m)', lwd= 3)
lines(therm.z.roll, lty ='dashed', lwd =3)
## decision if lake is stratified or not: 1 deg C criterium
strat.state <- um[1,] - um[nx,]
strat.state <- ifelse(strat.state > 1, 1, 0)
plot(seq(1, ncol(um))*dt/24/3600, strat.state, col = 'red', type = 'l',
xlab = 'Time (d)', ylab='Stratified conditions', ylim=c(0,1), lwd = 2)
## max. buoyancy frequency layer depth (direct model output)
mix.z.roll = zoo::rollmean(mix.z, 14)
plot(mix.z, type = 'l',ylim = rev(range( seq(0,zmax, length.out=nx))),
col = 'red', xlab = 'Time',
ylab= 'Max. Buoyancy Freq. Depth (m)', lwd= 3)
lines(mix.z.roll, lty ='dashed', lwd =3)
## check stratification durations
df.ice <- data.frame('time' = startDate + seq(1, ncol(um))*dt,
'ice' = Him,
'stratified' = strat.state)
g.ice <- ggplot(df.ice) +
geom_line(aes(time, ice)) +
ylab('ice thickness (m)') + xlab('')+
geom_line(aes(time, stratified),
linetype = 2, col = 'blue') +
scale_y_continuous(sec.axis = sec_axis(trans = ~ . & 1,
name = "stratified (yes/no)")) +
theme_minimal();g.ice
# meteorological heat fluxes
fluxes.df <- data.frame('time' =  startDate + seq(1, ncol(um))*dt,#/24/3600seq(1, ncol(um))*dt/24/3600,
'shortwave' = Swf,
'longwave' = Lwf + BLwf,
'latent' = Lf,
'sensible' = Sf,
'total' = Swf + Lwf + BLwf + Lf + Sf)
m.fluxes.df <- reshape2::melt(fluxes.df, id = 'time')
m.fluxes.df$type = 'model'
ggplot(m.fluxes.df) +
geom_line(aes(time, value)) +
facet_wrap(~ variable, scales = 'free')
glm.meteo <- read.csv('bc/lake.csv') %>%
rename(shortwave = Daily.Qsw, latent = Daily.Qe,
sensible = Daily.Qh, longwave = Daily.Qlw) %>%
mutate(total = shortwave + longwave + sensible + latent) %>%
select(time, shortwave, latent, sensible, longwave, total)
m.glm.meteo <- reshape2::melt(glm.meteo, id = 'time')
m.glm.meteo$type = 'GLM'
m.glm.meteo$time <- as.POSIXct(m.glm.meteo$time)
time =  startDate + seq(1, ncol(um))*dt
g.heat <- ggplot(m.fluxes.df, aes(time, value)) +
geom_line(aes(time, value, col = type)) +
geom_line(aes(y=zoo::rollmean(value, 24, na.pad=TRUE))) +
geom_line(data =  m.glm.meteo, aes(time, value, col = type)) +
xlim(min(time), max(time))+
facet_wrap(~ variable, scales = 'free'); g.heat
ggsave(filename = paste0('boundaryconditions','_',scheme,'_',nyear,'.png'),g.heat,  width = 15, height = 8, units = 'in')
## vertical water temperature profiles over time
df = data.frame('1' =NULL)
name = NULL
for (i in seq(1,ncol(um), length.out = 20)){
i = floor(i)
name = append(name, round((i*dt)/24/3600,1))
df = append(df, data.frame('1' = um[,i] + round((i*dt)/24/3600,1)))
}
df.m = matrix(unlist(df), ncol = 20)
colnames(df.m) = name
df.m.m = reshape2::melt(df.m)
ggplot2::ggplot(df.m.m) +
geom_point(aes(x = value/40, y=Var1,  col = value-Var2, group = Var2)) +
geom_line(aes(x = value/40, y=Var1,  col = value-Var2, group = Var2)) +
scale_y_reverse() + xlab('Time') + ylab('Depth')+labs(col='Temp')+
scale_color_gradient(low = "lightblue", high = "red") +
theme_minimal()
## contour plot of water temperature
# time =  seq(1, ncol(um))*dt/24/3600
time =  startDate + seq(1, ncol(um))*dt
df <- data.frame(cbind(time, t(um)) )
colnames(df) <- c("time", as.character(paste0(seq(1,nrow(um)))))
m.df <- reshape2::melt(df, "time")
m.df$time <- as.POSIXct(time)
df.kz <- data.frame(cbind(time, t(kzm)) )
colnames(df.kz) <- c("time", as.character(paste0(seq(1,nrow(kzm)))))
m.df.kz <- reshape2::melt(df.kz, "time")
m.df.kz$time <- as.POSIXct(time)
df.n2 <- data.frame(cbind(time, t(n2m)) )
colnames(df.n2) <- c("time", as.character(paste0(seq(1,nrow(n2m)))))
m.df.n2 <- reshape2::melt(df.n2, "time")
m.df.n2$time <- as.POSIXct(time)
g1 <- ggplot(m.df, aes((time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-2,40),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Temp [degC]')+
scale_y_reverse()
g2 <- ggplot(m.df.kz, aes((time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(#limits = c(-20,35),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Diffusion [m2/s]')+
scale_y_reverse()
g3 <- ggplot(m.df.n2, aes((time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(#limits = c(-20,35),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'N2 [s-2]')+
scale_y_reverse()
g <- g1 / g2 / g3 / g.ice; g
ggsave(filename = paste0('heatmaps','_',scheme,'_',nyear,'.png'),plot = g, width = 15, height = 8, units = 'in')
# Package ID: knb-lter-ntl.130.29 Cataloging System:https://pasta.edirepository.org.
# Data set title: North Temperate Lakes LTER: High Frequency Water Temperature Data - Lake  Mendota Buoy 2006 - current.
inUrl2  <- "https://pasta.lternet.edu/package/data/eml/knb-lter-ntl/130/29/63d0587cf326e83f57b054bf2ad0f7fe"
infile2 <- tempfile()
try(download.file(inUrl2,infile2,method="curl"))
if (is.na(file.size(infile2))) download.file(inUrl2,infile2,method="auto")
dt2 <-read.csv(infile2,header=F
,skip=1
,sep=","
,quot='"'
, col.names=c(
"sampledate",
"year4",
"month",
"daynum",
"hour",
"depth",
"wtemp",
"flag_wtemp"    ), check.names=TRUE)
unlink(infile2)
# attempting to convert dt2$sampledate dateTime string to R date structure (date or POSIXct)
tmpDateFormat<-"%Y-%m-%d"
tmp2sampledate<-as.Date(dt2$sampledate,format=tmpDateFormat)
# Keep the new dates only if they all converted correctly
if(length(tmp2sampledate) == length(tmp2sampledate[!is.na(tmp2sampledate)])){dt2$sampledate <- tmp2sampledate } else {print("Date conversion failed for dt2$sampledate. Please inspect the data and do the date conversion yourself.")}
rm(tmpDateFormat,tmp2sampledate)
if (class(dt2$year4)=="factor") dt2$year4 <-as.numeric(levels(dt2$year4))[as.integer(dt2$year4) ]
if (class(dt2$year4)=="character") dt2$year4 <-as.numeric(dt2$year4)
if (class(dt2$month)=="factor") dt2$month <-as.numeric(levels(dt2$month))[as.integer(dt2$month) ]
if (class(dt2$month)=="character") dt2$month <-as.numeric(dt2$month)
if (class(dt2$daynum)=="factor") dt2$daynum <-as.numeric(levels(dt2$daynum))[as.integer(dt2$daynum) ]
if (class(dt2$daynum)=="character") dt2$daynum <-as.numeric(dt2$daynum)
if (class(dt2$depth)=="factor") dt2$depth <-as.numeric(levels(dt2$depth))[as.integer(dt2$depth) ]
if (class(dt2$depth)=="character") dt2$depth <-as.numeric(dt2$depth)
if (class(dt2$wtemp)=="factor") dt2$wtemp <-as.numeric(levels(dt2$wtemp))[as.integer(dt2$wtemp) ]
if (class(dt2$wtemp)=="character") dt2$wtemp <-as.numeric(dt2$wtemp)
if (class(dt2$flag_wtemp)!="factor") dt2$flag_wtemp<- as.factor(dt2$flag_wtemp)
dt2$bhour <- ifelse(dt2$hour %/% 100 >= 1, dt2$hour/100, dt2$hour)
dt2$datetime <- as.POSIXct(paste0(dt2$sampledate,' ',dt2$bhour,':00:00'), format = "%Y-%m-%d %H:%M:%S")
# Package ID: knb-lter-ntl.29.29 Cataloging System:https://pasta.edirepository.org.
# Data set title: North Temperate Lakes LTER: Physical Limnology of Primary Study Lakes 1981 - current.
# inUrl3 <- "https://pasta.lternet.edu/package/data/eml/knb-lter-ntl/29/29/03e232a1b362900e0f059859abe8eb97"
# infile3 <- tempfile()
# download.file(inUrl3, infile3, method = "curl")
# dt1 <- read_csv(infile3, skip = 1, quote = "\"", guess_max = 1e+05,
#                 col_names = c("lakeid", "year4", "daynum", "sampledate",
#                               "depth", "rep", "sta", "event", "wtemp", "o2", "o2sat",
#                               "deck", "light", "frlight", "flagdepth", "flagwtemp",
#                               "flago2", "flago2sat", "flagdeck", "flaglight", "flagfrlight"))
# dt1
# time =  startDate + seq(1, ncol(um))*dt#/24/3600
# obs <- dt1 %>%
#   filter(lakeid == 'ME') %>%
#   rename(datetime = sampledate) %>%
#   select(datetime, depth, wtemp)
time =  startDate + seq(1, ncol(um))*dt#/24/3600
obs <- dt2 %>%
select(datetime, depth, wtemp)
df.sim <- df
colnames(df.sim) <- c("datetime", as.character(paste0('wtemp.',seq(1,nrow(um))*dx)))
df.sim$datetime <-   startDate + seq(1, ncol(um))*dt#/24/3600
# idx <- na.omit(match(as.POSIXct(df.sim$datetime), as.POSIXct(obs$datetime) ))
idx <- (match(as.POSIXct(obs$datetime), as.POSIXct(df.sim$datetime) ))
# df.sim <- df.sim[idx, ]
obs <- obs[which(!is.na(idx)), ]
idz <- which(obs$depth %in% seq(0,24,1))
obs = obs[idz,]
deps <- seq(1,nrow(um))*dx
if (min(unique(obs$depth)) < min(deps)){
deps[which.min(deps)] <- min(unique(obs$depth))
}
if (max(unique(obs$depth)) > max(deps)){
deps[which.max(deps)] <- max(unique(obs$depth))
}
df.sim.interp <- NULL
for (i in 1:nrow(df.sim)){
df.sim.interp <- rbind(df.sim.interp,
approx(deps, df.sim[i, -1], unique(obs$depth))$y)
}
df.sim.interp <- as.data.frame(df.sim.interp)
# df.sim.interp <- apply(df.sim[,-1], 1, function(x) approx(deps, x, unique(obs$temp_depth_m))$y)
df.sim.interp$datetime <-   startDate + seq(1, ncol(um))*dt#/24/3600
colnames(df.sim.interp) <- c(as.character(paste0('wtemp.',unique(obs$depth))), 'datetime')
obs <- data.frame(obs)
obs$depth <- factor(obs$depth)
wide.obs <- reshape(obs, idvar = "datetime", timevar = "depth", direction = "wide")
m.obs <- reshape2::melt(wide.obs, id = 'datetime')
m.obs$datetime <- as.POSIXct(m.obs$datetime)
m.obs$group <- 'obs'
m.df.sim.interp <- reshape2::melt(df.sim.interp, id = 'datetime')
m.df.sim.interp$group <- 'sim'
rmse <- data.frame('variable' = NULL, 'fit' = NULL)
for (i in unique(as.character(m.obs$variable))){
o <- m.obs
o$variable <- as.character(o$variable)
o = o %>%
filter(variable == i)
s <- m.df.sim.interp
s$variable <- as.character(s$variable)
s = s %>%
filter(variable == i)
id.r <-  (match(as.POSIXct(s$datetime), as.POSIXct(o$datetime) ))
s <- s[which(!is.na(id.r)),]
rmse <- rbind(rmse, data.frame('variable' = i,
'fit' = sqrt((sum((o$value-s$value)**2, na.rm = T))/nrow(o))))
}
m.obs$variable <-  factor(m.obs$variable, levels=paste0('wtemp.',seq(0,24,1)))
m.df.sim.interp$variable <-  factor(m.df.sim.interp$variable, levels=paste0('wtemp.',seq(0,24,1)))
ggplot() +
geom_point(data = m.obs,aes(datetime, value, col = group), size =0.3) +
geom_line(data = m.df.sim.interp, aes(datetime, value, col = group)) +
geom_text(data=rmse, aes( as.POSIXct("2010-01-01 10:30:00 CDT"), y=17, label=round(fit,2)),
color="black", size =3) +
# ylim(-5,40)+
facet_wrap(~ factor(variable, level = c(paste0('wtemp.',seq(0,24,1)))), scales = 'free') +
xlab('') + ylab('Temp. (deg C)')+
theme_bw()
ggsave(filename = paste0('fielcomparison','_',scheme,'_',nyear,'.png'), width = 15, height = 8, units = 'in')
## averaged responses
bf.obs <- apply(wide.obs[,-1], 1, function(x) rLakeAnalyzer::buoyancy.freq(wtr = x, depths = as.numeric(unique(obs$depth))))
bf.sim <- apply(df.sim.interp[,-22], 1, function(x) rLakeAnalyzer::buoyancy.freq(wtr = x, depths = as.numeric(unique(obs$depth))))
z.bf.obs <- apply(bf.obs,2, function(x) which.max(x))
z.bf.sim <- apply(bf.sim,2, function(x) which.max(x))
df.z.df.obs <- data.frame('time' = wide.obs$datetime, 'z' = as.numeric(z.bf.obs))
df.z.df.sim <- data.frame('time' = df.sim.interp$datetime, 'z' = z.bf.sim)
g.therm <- ggplot() +
geom_line(data = df.z.df.obs,
aes(time, z, col = 'observed'), alpha = 0.7) +
geom_line(data = df.z.df.sim,
aes(time, z, col = 'sim'), alpha = 0.7) +
scale_y_reverse() + xlab('Time') + ylab('Thermocline depth') +
theme_minimal()
avg.epi.obs <- NULL
avg.hyp.obs <- NULL
for (j in 1:nrow(df.z.df.obs)){
d = wide.obs[,-1]
if (is.na(df.z.df.obs$z[j])){
df.z.df.obs$z[j] = 1
}
avg.epi.obs <- append(avg.epi.obs,mean(as.numeric(d[j,1:df.z.df.obs$z[j]], na.rm = T)))
avg.hyp.obs <- append(avg.hyp.obs,mean(as.numeric(d[j,df.z.df.obs$z[j]:ncol(d)], na.rm = T)))
}
avg.epi.sim <- NULL
avg.hyp.sim <- NULL
for (j in 1:nrow(df.z.df.sim)){
d = df.sim.interp[,-22]
if (is.na(df.z.df.sim$z[j])){
df.z.df.sim$z[j] = 1
}
avg.epi.sim <- append(avg.epi.sim,mean(as.numeric(d[j,1:df.z.df.sim$z[j]], na.rm = T)))
avg.hyp.sim <- append(avg.hyp.sim,mean(as.numeric(d[j,df.z.df.sim$z[j]:ncol(d)], na.rm = T)))
}
df.avg.obs <- data.frame('time' = wide.obs$datetime,
'epi' = avg.epi.obs,
'hyp' = avg.hyp.obs,
'type' = 'obs')
df.avg.sim <- data.frame('time' = df.sim.interp$datetime,
'epi' = avg.epi.sim,
'hyp' = avg.hyp.sim,
'type' = 'sim')
g.avg <- ggplot() +
geom_point(data = df.avg.obs,
aes(time, epi, col = 'observed epi'), alpha = 0.7) +
geom_point(data = df.avg.obs,
aes(time, hyp, col = 'observed hyp'), alpha = 0.7) +
geom_line(data = df.avg.sim,
aes(time, epi, col = 'simulated epi'), alpha = 0.7) +
geom_line(data = df.avg.sim,
aes(time, hyp, col = 'simulated hyp'), alpha = 0.7) +
xlab('Time') + ylab('Average temp.') +
theme_minimal()
g.average <- g.therm / g.avg; g.average
ggsave(filename = paste0('averaged','_',scheme,'_',nyear,'.png'),plot = g.average, width = 15, height = 8, units = 'in')
# stratification dates
obs_dens <- abs(calc_dens(wide.obs$wtemp.1) - calc_dens(wide.obs$wtemp.20))
sim_dens <- abs(calc_dens(df.sim.interp$wtemp.1) - calc_dens(df.sim.interp$wtemp.20))
bindt <- ifelse(obs_dens >= 0.1, 1, 0)
bindt[which(is.na(bindt))] <- 0
bindy <- ifelse(sim_dens >= 0.1, 1, 0)
df.obs.dens <- data.frame('time' =  wide.obs$datetime,
'grad' =  bindt,
'year' = lubridate::year(wide.obs$datetime))
df.sim.dens <- data.frame('time' =  df.sim.interp$datetime,
'grad' =  bindy,
'year' = lubridate::year(df.sim.interp$datetime))
ggplot() +
geom_line(data = df.obs.dens, aes(time, grad, col ='obs'))+
geom_line(data = df.sim.dens, aes(time, grad,col='sim')) +
facet_wrap(~ year, scales = 'free')
for (t in unique(lubridate::year(df.obs.dens$time))){
d = df.obs.dens %>%
filter(year == t)
for (i in (1+24*15):(nrow(d) -24*15)){
if (all(bindt[(i-1-24*15):(i-1)] != 1) & all(bindt[i:(i+(24*15))] == 1))
print(paste0('start: ',d$datetime[i]))
if (all(bindt[(i-1-24*15):(i-1)] == 1) & all(bindt[i:(i+(24*15))] != 1))
print(paste0('end: ',d$datetime[i]))
}
}
for (i in (1+24*30):(length(sim_dens)-(60*24))){
if (all(bindy[(i-1-24*30):(i-1)] != 1) & all(bindy[i:(i+(24*30))] == 1))
print(paste0('start: ',df.sim.interp$datetime[i]))
if (all(bindy[(i-1-24*30):(i-1)] == 1) & all(bindy[i:(i+(24*30))] != 1))
print(paste0('end: ',df.sim.interp$datetime[i]))
}
## vertical temperature profiles
for (i in seq(1,ncol(um), length.out = 200)){
n = i
i = floor(i)
sim = m.df.sim.interp %>%
filter(datetime == time[i]) %>%
mutate(group = 'modeled') %>%
mutate(depth =  as.numeric(gsub(".*wtemp.","",as.character(factor(variable, level = c(paste0('wtemp.',seq(0,24,1))))))))
obs = m.obs %>%
filter(datetime == time[i]) %>%
mutate(group = 'observed') %>%
mutate(depth =  as.numeric(gsub(".*wtemp.","",as.character(factor(variable, level = c(paste0('wtemp.',seq(0,24,1))))))))
ggplot() +
geom_path(data = sim, aes(value,
depth, col = group), size = 1.2) +
# facet_wrap(~ factor(variable, level = c(paste0('wtemp.',seq(0,24,1)))), scales = 'free') +
geom_point(data = obs ,aes(value, depth, col = group), size =1.2) +
xlab('temp. (deg C)') + ylab('depth (m)')+
scale_y_reverse() +
scale_color_manual(values = c("#E69F00", "#56B4E9")) +
ggtitle( time[i]) +
labs(col='') +
xlim(-5, 35) +
theme_bw()
ggsave(paste0('../../animation_mendota/pic_',match(n, seq(1,ncol(um),length.out=200)),'.png'),
width = 4, height = 5, units = 'in')
}
#' Created on Thu Aug 19 11:29:34 2021
#'
#' @author: Robert Ladwig
#' @email: rladwig2@wisc.edu
## remove everything from workspace
rm(list = ls())
# set wd to current dir of script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
## colors for plotting
library(tidyverse)
library(RColorBrewer)
library(patchwork)
source('1D_HeatMixing_functions.R')
## lake configurations
zmax = 25 # maximum lake depth
nx = 25 # number of layers we will have
dt = 3600 # 24 hours times 60 min/hour times 60 seconds/min
dx = zmax/nx # spatial step
## area and depth values of our lake
hyps_all <- get_hypsography(hypsofile = 'bc/LakeEnsemblR_bathymetry_standard.csv',
dx = dx, nx = nx)
## here we define our initial profile
u <- initial_profile(initfile = 'bc/obs.txt', nx = nx, dx = dx,
depth = hyps_all[[3]])
## atmo8,spheric boundary conditions
meteo_all <- provide_meteorology(meteofile = 'bc/LakeEnsemblR_meteo_standard.csv',
secchifile = 'bc/light.csv',
windfactor = 0.8)
### EXAMPLE RUNS
# 1 day
temp <- c()
avgtemp <- c()
res <- run_thermalmodel(u = u,
startTime = 1,
endTime = 24*3600,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]])
temp <-cbind(temp, res$temp)
avgtemp <- rbind(avgtemp, res$average)
# doing another day
for (i in 1:365){
res <-  run_thermalmodel(u = res$temp[, ncol(res$temp)],
startTime = res$endtime,
endTime =  res$endtime + 24*3600,
ice = res$iceflag,
Hi = res$icethickness,
iceT = res$icemovAvg,
supercooled = res$supercooled,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 1e-7)
temp <-cbind(temp, res$temp[,-1])
avgtemp <- rbind(avgtemp, res$average[-1,])
}
plot(seq(1, ncol(temp))*dt/24/3600, temp[1,], col = 'red', type = 'l',
xlab = 'Time (d)', ylab='Temperature (degC)', ylim=c(-1,35), lwd = 2)
for (i in 2:nx){
lines(seq(1, ncol(temp))*dt/24/3600, temp[i,],
lty = 'dashed',lwd =2)
}
ggplot(avgtemp) +
geom_line(aes(time, epi, col = 'epilimnion')) +
geom_line(aes(time, hyp, col = 'hypolimnion')) +
geom_line(aes(time, tot, col = 'total')) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, stratFlag)) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, thermoclineDep)) +
theme_minimal()
time =  seq(1, ncol(temp), 1)
df <- data.frame(cbind(time, t(temp)) )
colnames(df) <- c("time", as.character(paste0(seq(1,nrow(temp)))))
m.df <- reshape2::melt(df, "time")
ggplot(m.df, aes((time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-2,30),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Temp [degC]')+
scale_y_reverse()

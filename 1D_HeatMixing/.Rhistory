target.fit = 2.0     # refers to a target fit of 2.0 degrees Celsius (stops when RMSE is below that)
target.iter = 20    # refers to a maximum run of 20 calibration iterations (stops after that many runs)
plotting = TRUE      # if TRUE, script will automatically save the contour plots
output = out_file    # path of the output file
field_file = field_data # path of the field data
conversion.factor = 1 # conversion factor for the output, e.g. 1 for water temp.
calibrate_sim(var = 'temp', path = sim_folder,
field_file = field_file,
nml_file = nml_file,
glm_file = glm_file,
calib_setup = calib_setup,
glmcmd = NULL, first.attempt = TRUE,
period = period,
scaling = TRUE, method = 'CMA-ES', metric = 'RMSE',
target.fit = 0.1, target.iter = 100,
plotting = TRUE,
output = output,
verbose = TRUE,
conversion.factor = 1)
nc_file = out_file # the GLM output
field_file = field_data # observed data
var_name = 'temp'
fig_path = paste0('comparison.png')
text.size = 10
width = 6.5
height = 5
units = 'in'
precision = 'hours' # if models runs on hourly time step
conversion = NULL # conversion factor, change to 1 if everything's in mmol/m3
legend.title = 'Temp. (deg C)'
resample = TRUE
interval = 0.1
method = 'match'
color.palette = 'RdYlBu' # which colors do you like?
color.direction = -1
obs.color = 'white'
obs.alpha = 0.2
obs.shape = 16
obs.size = 1
shiftPalette = NULL
zlim = c(15,45) # limit of axis
na_value = 'grey90' # color of values that exceed zlim
library(ncdf4)
.is_heatmap <- function(file, var_name){
glm_nc <- get_glm_nc(file)
in.nc <- var_name %in% names(glm_nc$var)
if (!all(in.nc)){
close_glm_nc(glm_nc)
stop(paste(var_name[!in.nc], collapse=', '),' not in ', file)
}
dims <-unlist(lapply(X = var_name, FUN = function(x) length(glm_nc$var[[x]]$dim)))
close_glm_nc(glm_nc)
#dim == 4 is heatmap (3D)
return(dims==4 | dims == 0)
}
get_glm_nc  <-  function(file){
if(length(file) < 1 || is.na(file)){
stop('glm_nc file must be supplied string or proper file handle')
}
glm_nc	<- 	nc_open(file, readunlim=TRUE)
return(glm_nc)
}
close_glm_nc <- function(glm_nc){
nc_close(glm_nc)
}
heatmaps <- .is_heatmap(nc_file, var_name)
if (!heatmaps){
warning('plot_var_compare not implemented for 1D variables')
return()
}
surface <- get_surface_height(nc_file)
max_depth <- max(surface[, 2])
min_depth <- 0
z_out <- seq(min_depth, max_depth,by = interval) # Set plotting interval
modeled_var = get_var(nc_file, var_name, reference='surface',z_out = z_out)
# Resample
data = resample_to_field(nc_file, field_file, var_name=var_name, method = method, precision = precision) %>%
mutate(type = as.factor('Observed'))
dataClean = data %>% dplyr::filter_all(all_vars(!is.na(.data$.)))
library(akima)
.interpolate2grid <- function(xyzData, xcol = 1, ycol = 2, zcol = 3, precision = precision,
interval = interval) {
# Interpolate field or modeled data to grid
# xcol, ycol, and zcol and column numbers from data.frame
# The spreads of x and y must be within four orders of magnitude of each other for interp to work
# Therefore must scale data to be within similar magnitude to numeric dates (1e6)
gridData <-interp2xyz(akima::interp(x = as.numeric(xyzData[,xcol]), y=(xyzData[,ycol]*1e6), z=xyzData[,zcol], duplicate="mean", linear = T,
xo = as.numeric(seq(min(xyzData[,xcol]), max(xyzData[,xcol]), by = precision)),
yo = 1e6*seq(min(xyzData[,ycol]), max(xyzData[,ycol]), by = interval)), data.frame=TRUE) %>%
dplyr::mutate(x =  as.POSIXct(x, origin = '1970-01-01', tz = Sys.timezone())) %>%
dplyr::mutate(y = y/1e6) %>%
dplyr::arrange(x,y)
return(gridData)
}
# Akima interpolation of observed data (Gridded Bivariate Interpolation for Irregular Data)
observed_df <- .interpolate2grid(dataClean, xcol = 1, ycol = 2, zcol = 3, precision = precision,
interval = interval) %>%
rename(DateTime = .data$x, Depth = .data$y, var = .data$z)
# Should modeled data be resampled to match resolution of field data?
# Akima interpolation of observed data (Gridded Bivariate Interpolation for Irregular Data)
model_df <- .interpolate2grid(dataClean, xcol = 1, ycol = 2, zcol = 4, precision = precision,
interval = interval)
names(model_df) = c('DateTime','Depth','var')
if(is.null(legend.title)) {
legend.title = .unit_label(nc_file, var_name)
}
if (!is.null(conversion))  {model_df = model_df %>% mutate(var = .data$var * conversion)}
dfCombine = mutate(observed_df, type = 'Observed') %>%
bind_rows(mutate(model_df, type = 'Modeled')) %>%
mutate(type = factor(.data$type, levels=c('Observed','Modeled')))
h3 = ggplot(data = dfCombine, aes(.data$DateTime, .data$Depth)) +
geom_raster(aes(fill = .data$var), interpolate = F) +
geom_point(data = data, aes(x = .data$DateTime, y = .data$Depth), color = obs.color, alpha = obs.alpha, shape = obs.shape, size = obs.size) +
scale_y_reverse(expand = c(0.01,0.01)) +
scale_x_datetime(expand = c(0.01,0.01), limits = c(min(dfCombine$DateTime), max(dfCombine$DateTime))) +
scale_fill_distiller(palette = color.palette, direction = color.direction, na.value = na_value, values = shiftPalette, limits = zlim) +
ylab('Depth (m)') + xlab('Date') +
facet_wrap(type ~ ., ncol = 1) +
labs(fill = legend.title) +
theme_bw(base_size = text.size)+
theme(axis.title.x = element_blank(),
legend.justification=c(0.9,1),
legend.position = "top",
legend.text = element_text(size = 7),
legend.title = element_text(size = 7),
legend.key.width =  unit(0.7, "in"),
legend.key.height =  unit(0.08, "in"),
legend.margin=margin(0,0,0,0),
legend.box.margin=margin(0,-10,-5,-10))
h3
ggsave('comparison.png', width = 18, height = 13, unit = 'in')
# use rLakeAnalyzer to calculate physical derivatives, e.g. thermocline depth
wtr_data <- get_var(file = out_file,
var_name = 'temp',
reference = 'surface')
str(wtr_data)
# transform data into rLakeAnalyzer format
wtr_df <- data.frame('datetime' = wtr_data$DateTime,
as.matrix(wtr_data[, 2:ncol(wtr_data)]))
colnames(wtr_df) <- c('datetime',paste("wtr_", round(as.numeric(sub(".*_", "", colnames(wtr_df[-1]))),1), sep=""))
td_df <- ts.thermo.depth(wtr = wtr_df, Smin = 0.1, na.rm = TRUE)
ggplot(td_df, aes(datetime, thermo.depth)) +
geom_line() +
ggtitle('Thermocline depth') +
xlab(label = '') + ylab(label = 'Depth (m)') +
scale_y_continuous(trans = "reverse") +
theme_minimal()
ggsave('thermocline.png', width = 6, height = 4, unit = 'in')
# vertical temperature profiles
for (i in seq(1,length(unique(dfCombine$DateTime)), length.out = 200)){
n = i
i = floor(i)
time = unique(dfCombine$DateTime)
sim = dfCombine %>%
filter(DateTime == time[i] & type == 'Modeled')
obs = dfCombine %>%
filter(DateTime == time[i] & type == 'Observed')
ggplot() +
geom_path(data = sim, aes(var,
Depth, col = type), size = 1.2) +
geom_point(data = obs ,aes(var, Depth, col = type), size =1.2) +
xlab('temp. (deg C)') + ylab('depth (m)')+
scale_y_reverse() +
scale_color_manual(values = c('#69b3a2',"#E69F00", "#56B4E9")) +
ggtitle( time[i]) +
labs(col='') +
xlim(15, 40) +
theme_bw()
ggsave(paste0('animation/pic_',match(n, seq(1,length(unique(dfCombine$DateTime)), length.out = 200)),'.png'),
width = 4, height = 5, units = 'in')
}
#' Created on Thu Aug 19 11:29:34 2021
#'
#' @author: Robert Ladwig
#' @email: rladwig2@wisc.edu
## remove everything from workspace
rm(list = ls())
# set wd to current dir of script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
## colors for plotting
library(tidyverse)
library(RColorBrewer)
library(patchwork)
source('1D_HeatMixing_functions.R')
## lake configurations
zmax = 25 # maximum lake depth
nx = 25 # number of layers we will have
dt = 3600 # 24 hours times 60 min/hour times 60 seconds/min
dx = zmax/nx # spatial step
## area and depth values of our lake
hyps_all <- get_hypsography(hypsofile = 'bc/LakeEnsemblR_bathymetry_standard.csv',
dx = dx, nx = nx)
## here we define our initial profile
u <- initial_profile(initfile = 'bc/obs.txt', nx = nx, dx = dx,
depth = hyps_all[[3]])
## atmospheric boundary conditions
meteo_all <- provide_meteorology(meteofile = 'bc/LakeEnsemblR_meteo_standard.csv',
secchifile = 'bc/light.csv',
windfactor = 0.8)
### EXAMPLE RUNS
# 1 day
temp <- c()
avgtemp <- c()
diff <- c()
res <- run_thermalmodel(u = u,
startTime = 1,
endTime = 24*3600,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp)
avgtemp <- rbind(avgtemp, res$average)
diff <-cbind(diff, res$diff)
# doing another day
for (i in 1:365){
res <-  run_thermalmodel(u = res$temp[, ncol(res$temp)],
startTime = res$endtime,
endTime =  res$endtime + 24*3600,
ice = res$iceflag,
Hi = res$icethickness,
iceT = res$icemovAvg,
supercooled = res$supercooled,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp[,-1])
avgtemp <- rbind(avgtemp, res$average[-1,])
diff <-cbind(diff, res$diff[,-1])
}
avgtemp_default = avgtemp
### EXAMPLE RUNS
# 1 day
temp <- c()
avgtemp <- c()
diff <- c()
res <- run_thermalmodel(u = u,
startTime = 1,
endTime = 24*3600,
kd_light = 0.15,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp)
avgtemp <- rbind(avgtemp, res$average)
diff <-cbind(diff, res$diff)
# doing another day
for (i in 1:365){
res <-  run_thermalmodel(u = res$temp[, ncol(res$temp)],
startTime = res$endtime,
endTime =  res$endtime + 24*3600,
ice = res$iceflag,
Hi = res$icethickness,
iceT = res$icemovAvg,
supercooled = res$supercooled,
kd_light = 0.15,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp[,-1])
avgtemp <- rbind(avgtemp, res$average[-1,])
diff <-cbind(diff, res$diff[,-1])
}
ggplot() +
geom_line(data = avgtemp_default, aes(time, epi, col = 'default')) +
geom_line(data = avgtemp,aes(time, epi, col = 'kd=1.5')) +
theme_minimal()
ggplot() +
geom_line(data = avgtemp_default, aes(time, epi, col = 'default')) +
geom_line(data = avgtemp,aes(time, epi, col = 'kd=0.15')) +
theme_minimal()
secview = meteo_all[[2]]
plot(secview$sampledate, secview$kd)
plot(secview$sampledate, secview$kd)
dev.off()
plot(secview$sampledate, secview$kd)
lines(secview$sampledate, secview$kd)
# plotting for checking model output and performance
plot(seq(1, ncol(temp))*dt/24/3600, temp[1,], col = 'red', type = 'l',
xlab = 'Time (d)', ylab='Temperature (degC)', ylim=c(-1,35), lwd = 2)
for (i in 2:nx){
lines(seq(1, ncol(temp))*dt/24/3600, temp[i,],
lty = 'dashed',lwd =2)
}
time
time =  seq(1, ncol(temp), 1)
ggplot(avgtemp) +
geom_line(aes(time, epi, col = 'epilimnion')) +
geom_line(aes(time, hyp, col = 'hypolimnion')) +
geom_line(aes(time, tot, col = 'total')) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, stratFlag)) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, thermoclineDep)) +
theme_minimal()
df <- data.frame(cbind(time, t(temp)) )
colnames(df) <- c("time", as.character(paste0(seq(1,nrow(temp)))))
m.df <- reshape2::melt(df, "time")
ggplot(m.df, aes((time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-2,35),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Temp [degC]')+
scale_y_reverse()
?approxfun
kd <- approxfun(x = secview$dt, y = secview$kd, method = "constant", rule = 2)
kd(100)
kd(10000)
kd(10000000)
10000000/86400
kd(250*86400)
#' Created on Thu Aug 19 11:29:34 2021
#'
#' @author: Robert Ladwig
#' @email: rladwig2@wisc.edu
## remove everything from workspace
rm(list = ls())
# set wd to current dir of script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
## colors for plotting
library(tidyverse)
library(RColorBrewer)
library(patchwork)
source('1D_HeatMixing_functions.R')
## lake configurations
zmax = 25 # maximum lake depth
nx = 25 # number of layers we will have
dt = 3600 # 24 hours times 60 min/hour times 60 seconds/min
dx = zmax/nx # spatial step
## area and depth values of our lake
hyps_all <- get_hypsography(hypsofile = 'bc/LakeEnsemblR_bathymetry_standard.csv',
dx = dx, nx = nx)
## here we define our initial profile
u <- initial_profile(initfile = 'bc/obs.txt', nx = nx, dx = dx,
depth = hyps_all[[3]])
## atmospheric boundary conditions
meteo_all <- provide_meteorology(meteofile = 'bc/LakeEnsemblR_meteo_standard.csv',
secchifile = 'bc/light.csv',
windfactor = 0.8)
### EXAMPLE RUNS
# 1 day
temp <- c()
avgtemp <- c()
diff <- c()
res <- run_thermalmodel(u = u,
startTime = 1,
endTime = 24*3600,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp)
avgtemp <- rbind(avgtemp, res$average)
diff <-cbind(diff, res$diff)
# doing another day
for (i in 1:365){
res <-  run_thermalmodel(u = res$temp[, ncol(res$temp)],
startTime = res$endtime,
endTime =  res$endtime + 24*3600,
ice = res$iceflag,
Hi = res$icethickness,
iceT = res$icemovAvg,
supercooled = res$supercooled,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp[,-1])
avgtemp <- rbind(avgtemp, res$average[-1,])
diff <-cbind(diff, res$diff[,-1])
}
# plotting for checking model output and performance
plot(seq(1, ncol(temp))*dt/24/3600, temp[1,], col = 'red', type = 'l',
xlab = 'Time (d)', ylab='Temperature (degC)', ylim=c(-1,35), lwd = 2)
for (i in 2:nx){
lines(seq(1, ncol(temp))*dt/24/3600, temp[i,],
lty = 'dashed',lwd =2)
}
time =  seq(1, ncol(temp), 1)
ggplot(avgtemp) +
geom_line(aes(time, epi, col = 'epilimnion')) +
geom_line(aes(time, hyp, col = 'hypolimnion')) +
geom_line(aes(time, tot, col = 'total')) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, stratFlag)) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, thermoclineDep)) +
theme_minimal()
df <- data.frame(cbind(time, t(temp)) )
colnames(df) <- c("time", as.character(paste0(seq(1,nrow(temp)))))
m.df <- reshape2::melt(df, "time")
ggplot(m.df, aes((time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-2,35),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Temp [degC]')+
scale_y_reverse()
ggplot(avgtemp) +
geom_line(aes(time, epi, col = 'epilimnion')) +
geom_line(aes(time, hyp, col = 'hypolimnion')) +
geom_line(aes(time, tot, col = 'total')) +
theme_minimal()
avtemp_null = avgtemp
temp <- c()
avgtemp <- c()
diff <- c()
res <- run_thermalmodel(u = u,
startTime = 1,
endTime = 24*3600,
kd_light = 0.15,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp)
avgtemp <- rbind(avgtemp, res$average)
diff <-cbind(diff, res$diff)
# doing another day
for (i in 1:365){
res <-  run_thermalmodel(u = res$temp[, ncol(res$temp)],
startTime = res$endtime,
endTime =  res$endtime + 24*3600,
ice = res$iceflag,
Hi = res$icethickness,
iceT = res$icemovAvg,
supercooled = res$supercooled,
kd_light = 0.15,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp[,-1])
avgtemp <- rbind(avgtemp, res$average[-1,])
diff <-cbind(diff, res$diff[,-1])
}
ggplot() +
geom_line(data = avtemp_null, aes(time, epi, col = 'null')) +
geom_line(data = avtemp, aes(time, epi, col = '0.15')) +
theme_minimal()
ggplot() +
geom_line(data = avtemp_null, aes(time, epi, col = 'epi_null')) +
geom_line(data = avgtemp, aes(time, epi, col = 'epi_0.15')) +
geom_line(data = avtemp_null, aes(time, hyp, col = 'hyp_null')) +
geom_line(data = avgtemp, aes(time, hyp, col = 'hyp_0.15')) +
theme_minimal()
ggplot() +
geom_line(data = avtemp_null, aes(time, tot, col = 'null')) +
geom_line(data = avgtemp, aes(time, tot, col = '0.15')) +
theme_minimal()

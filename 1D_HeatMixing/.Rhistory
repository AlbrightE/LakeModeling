if (scheme == 'explicit'){
u[1] = un[1] +
(Q * area[1]/(dx)*1/(4184 * calc_dens(un[1]) ) +
abs(H[1+1]-H[1]) * area[1]/(dx) * 1/(4184 * calc_dens(un[1]) ) +
Hg[1]) * dt/area[1]
# all other layers in between
for (i in 2:(nx-1)){
u[i] = un[i] +
(area[i] * kzn[i] * 1 / dx**2 * (un[i+1] - 2 * un[i] + un[i-1]) +
abs(H[i+1]-H[i]) * area[i]/(dx) * 1/(4184 * calc_dens(un[i]) ) +
Hg[i])* dt/area[i]
}
# bottom layer
u[nx] = un[nx] +
abs(H[nx]-H[nx-1]) * area[nx]/(area[nx]*dx) * 1/(4181 * calc_dens(un[nx]) +
Hg[nx]/area[nx]) * dt
}
## (3) TURBULENT MIXING OF MIXED LAYER
# the mixed layer depth is determined for each time step by comparing kinetic
# energy available from wind and the potential energy required to completely
# mix the water column to a given depth
Zcv <- seq(1, nx) %*% area / sum(area) # center of volume
tau = 1.225 * Cd * Uw(n)^2 # wind shear is air density times wind velocity
if (Uw(n) <= 15) {
c10 = 0.0005 * sqrt(Uw(n))
} else {
c10 = 0.0026
}
shear = sqrt((c10 * calc_dens(un[1]))/1.225) *  Uw(n) # shear velocity
# coefficient times wind velocity squared
KE = shear *  tau * dt # kinetic energy as function of wind
if (ice){
KE = KE * KEice
}
maxdep = 1
for (dep in 1:(nx-1)){
if (dep == 1){
# PE = abs(g *  ( seq(1,nx)[dep] - Zcv)  * calc_dens(u[dep]) * dx)
PE = abs(g *   seq(1,nx)[dep] *( seq(1,nx)[dep+1] - Zcv)  *
# abs(calc_dens(u[dep+1])- calc_dens(u[dep])))
abs(calc_dens(u[dep+1])- mean(calc_dens(u[1:dep]))))
} else {
PEprior = PE
# PE = abs(g *  ( seq(1,nx)[dep] - Zcv)  * calc_dens(u[dep]) * dx +
#            PEprior)
PE = abs(g *   seq(1,nx)[dep] *( seq(1,nx)[dep+1] - Zcv)  *
# abs(calc_dens(u[dep+1])- calc_dens(u[dep]))) + PEprior
abs(calc_dens(u[dep+1])- mean(calc_dens(u[1:dep])))) + PEprior
}
if (PE > KE){
maxdep = dep-1
break
} else if (dep>1 & PE < KE ){
u[(dep-1):dep] = (u[(dep-1):dep] %*% volume[(dep-1):dep])/sum(volume[(dep-1):dep])
}
maxdep = dep
}
# u[1:maxdep] = (u[1:(maxdep)] %*% volume[1:(maxdep)])/sum(volume[1:(maxdep)]) #mean(u[1:maxdep])
mix[match(n, seq(startTime, endTime, dt))] <- KE/PE #append(mix, KE/PE)
therm.z[match(n, seq(startTime, endTime, dt))] <- maxdep #append(therm.z, maxdep)
## (4) DENSITY INSTABILITIES
# convective overturn: Convective mixing is induced by an unstable density
# profile. All groups of water layers where the vertical density profile is
# unstable are mixed with the first stable layer below the unstable layer(s)
# (i.e., a layer volume weighed means of temperature and other variables are
# calculated for the mixed water column). This procedure is continued until
# the vertical density profile in the whole water column becomes neutral or stable.
dens_u = calc_dens(u)
diff_dens_u <- (diff(dens_u))
diff_dens_u[abs(diff(dens_u)) <= densThresh] = 0
while (any(diff_dens_u < 0)){
dens_u = calc_dens(u)
for (dep in 1:(nx-1)){
if (dens_u[dep+1] < dens_u[dep] & abs(dens_u[dep+1] - dens_u[dep]) >= densThresh){
u[dep:(dep+1)] = (u[dep:(dep+1)] %*% volume[dep:(dep+1)])/sum(volume[dep:(dep+1)]) #mean(u[dep:(dep+1)])
break
}
}
dens_u = calc_dens(u)
diff_dens_u <- (diff(dens_u))
diff_dens_u[abs(diff(dens_u)) <= densThresh] = 0
}
dens_u_n2 = calc_dens(u)
n2 <- 9.81/mean(calc_dens(u)) * (lead(dens_u_n2) - lag(dens_u_n2))/dx
max.n2 <- ifelse(max(n2, na.rm = T) > 1E-4, which.max(n2) * dx, dx * nx)
mix.z[match(n, seq(startTime, endTime, dt))] <- max.n2
## (5) ICE FORMATION
# according to Hostetler & Bartlein (1990):
# (1) ice forms when surface water temp <= 1 deg C and melts when > 1 deg
# (2) rate of ice formation/melting is exponential function of ice thickness
# (the thicker the ice, the slower the formation rate, and vice versa)
# (3) heat of fusion is added/subtracted from surface energy balance
# (4) diffusion below ice only happens on molecular level
# (5) with ice, surface absorption of incoming solar radiation increases to 85 %
icep  = max(dt_iceon_avg,  (dt/86400))
x = (dt/86400) / icep
iceT = iceT * (1 - x) + u[1] * x
if ((iceT <= 0) == TRUE & Hi < Ice_min){
# if (any(u <= 0) == TRUE){
supercooled <- which(u < 0)
initEnergy <- sum((0-u[supercooled])*area[supercooled] * dx * 4.18E6)
if (ice != TRUE) {
Hi <- Ice_min+(initEnergy/(910*333500))/max(area)
} else {
if (Tair(n) > 0){
Tice <- 0
Hi = Hi -max(c(0, meltP * dt*((absorp*Jsw(n))+(longwave(cc = CC(n), sigma = sigma, Tair = Tair(n), ea = ea(n), emissivity = emissivity, Jlw = Jlw(n)) +
backscattering(emissivity = emissivity, sigma = sigma, Twater = un[1], eps = eps) +
latent(Tair = Tair(n), Twater = un[1], Uw = Uw(n ), p2 = p2, pa = Pa(n), ea=ea(n),  RH = RH(n)) +
sensible(p2 = p2, B = B, Tair = Tair(n), Twater = un[1], Uw = Uw(n))) )/(1000*333500)))
} else {
Tice <-  ((1/(10 * Hi)) * 0 +  Tair(n)) / (1 + (1/(10 * Hi)))
Hi <- min(Ice_min, sqrt(Hi**2 + 2 * 2.1/(910 * 333500)* (0 - Tice) * dt))
}
}
ice = TRUE
if (Hi > 0){
u[supercooled] = 0
u[1] = 0
}
Him[ match(n, seq(startTime, endTime, dt))] <- Hi
} else if (ice == TRUE & Hi >= Ice_min) {
if (Tair(n) > 0){
Tice <- 0
Hi = Hi -max(c(0, meltP * dt*((absorp*Jsw(n))+(backscattering(emissivity = emissivity, sigma = sigma, Twater = un[1], eps = eps) +
latent(Tair = Tair(n), Twater = un[1], Uw = Uw(n ), p2 = p2, pa = Pa(n), ea=ea(n*dt),  RH = RH(n)) +
sensible(p2 = p2, B = B, Tair = Tair(n), Twater = un[1], Uw = Uw(n))) )/(1000*333500)))
} else {
Tice <-  ((1/(10 * Hi)) * 0 +  Tair(n*dt)) / (1 + (1/(10 * Hi)))
Hi <- min(Ice_min, sqrt(Hi**2 + 2 * 2.1/(910 * 333500)* (0 - Tice) * dt))
}
u[supercooled] = 0
u[1] = 0
Him[ match(n, seq(startTime, endTime, dt))] <- Hi
} else if (ice == TRUE & Hi < Ice_min){
ice = FALSE
}
n2m[, match(n, seq(startTime, endTime, dt))] <- n2
um[, match(n, seq(startTime, endTime, dt))] <- u
}
end.time <- Sys.time()
time.taken <- end.time - start.time
print(time.taken)
# time =  startDate + seq(1, ncol(um))*dt#/24/3600
df.sim <- data.frame(cbind(seq(startTime,endTime,dt), t(um)) )
colnames(df.sim) <- c("datetime", as.character(paste0('wtemp.',seq(1,nrow(um))*dx)))
df.sim$datetime <-   seq(startTime, endTime, dt)#/24/3600
## averaged responses
bf.sim <- apply(df.sim[,-1], 1, function(x) rLakeAnalyzer::buoyancy.freq(wtr = x, depths = seq(1,nrow(um))*dx))
bf.sim <- apply(df.sim[,-1], 1, function(x) rLakeAnalyzer::center.buoyancy(wtr = x, depths = seq(1,nrow(um))*dx))
# z.bf.sim <- apply(bf.sim,2, function(x) which.max(x))
df.z.df.sim <- data.frame('time' = df.sim$datetime, 'z' = bf.sim)
avg.epi.sim <- NULL
avg.hyp.sim <- NULL
avg.tot.sim <- NULL
for (j in 1:nrow(df.z.df.sim)){
d = df.sim[,-1]
if (is.na(df.z.df.sim$z[j])){
df.z.df.sim$z[j] = 1
}
avg.epi.sim <- append(avg.epi.sim,((as.numeric(d[j,1:df.z.df.sim$z[j]], na.rm = T) %*%
area[1:df.z.df.sim$z[j]] )/
sum(area[1:df.z.df.sim$z[j]])))
avg.hyp.sim <- append(avg.hyp.sim,((as.numeric(d[j,df.z.df.sim$z[j]:ncol(d)], na.rm = T)%*%
area[df.z.df.sim$z[j]:ncol(d)] )/
sum(area[df.z.df.sim$z[j]:ncol(d)])))
avg.tot.sim <- append(avg.tot.sim,((as.numeric(d[j,1:ncol(d)], na.rm = T)%*%
area[1:ncol(d)] )/
sum(area[1:ncol(d)])))
}
stratFlag = rep(NA, length = ncol(um))
for (v in 1:length(stratFlag)){
stratFlag[v] = ifelse((calc_dens(um[nrow(um),v]) - calc_dens(um[1,v])) >= 0.1 &
mean(um[,v]) >= 4, 1, 0)
}
df.avg.sim <- data.frame('time' = df.sim$datetime,
'epi' = avg.epi.sim,
'hyp' = avg.hyp.sim,
'tot' = avg.tot.sim,
'stratFlag' = stratFlag,
'thermoclineDep' = bf.sim)
return(list('temp'  = um,
'diff' = kzm,
'mixing' = mix,
'buoyancy' = n2m,
'icethickness' = Hi,
'iceflag' = ice,
'icemovAvg' = iceT,
'supercooled' = supercooled,
'mixingdepth' = mix.z,
'thermoclinedepth' = therm.z,
'endtime' = endTime,
'average' = df.avg.sim))
}
#' Created on Thu Aug 19 11:29:34 2021
#'
#' @author: Robert Ladwig
#' @email: rladwig2@wisc.edu
## remove everything from workspace
rm(list = ls())
# set wd to current dir of script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
## colors for plotting
library(tidyverse)
library(RColorBrewer)
library(patchwork)
source('1D_HeatMixing_functions.R')
## lake configurations
zmax = 25 # maximum lake depth
nx = 25 # number of layers we will have
dt = 3600 # 24 hours times 60 min/hour times 60 seconds/min
dx = zmax/nx # spatial step
## area and depth values of our lake
hyps_all <- get_hypsography(hypsofile = 'bc/LakeEnsemblR_bathymetry_standard.csv',
dx = dx, nx = nx)
## here we define our initial profile
u <- initial_profile(initfile = 'bc/obs.txt', nx = nx, dx = dx,
depth = hyps_all[[3]])
## atmo8,spheric boundary conditions
meteo_all <- provide_meteorology(meteofile = 'bc/LakeEnsemblR_meteo_standard.csv',
secchifile = 'bc/light.csv',
windfactor = 0.8)
### EXAMPLE RUNS
# 1 day
temp <- c()
avgtemp <- c()
res <- run_thermalmodel(u = u,
startTime = 1,
endTime = 24*3600,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp)
avgtemp <- rbind(avgtemp, res$average)
# doing another day
for (i in 1:365){
res <-  run_thermalmodel(u = res$temp[, ncol(res$temp)],
startTime = res$endtime,
endTime =  res$endtime + 24*3600,
ice = res$iceflag,
Hi = res$icethickness,
iceT = res$icemovAvg,
supercooled = res$supercooled,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp[,-1])
avgtemp <- rbind(avgtemp, res$average[-1,])
}
plot(seq(1, ncol(temp))*dt/24/3600, temp[1,], col = 'red', type = 'l',
xlab = 'Time (d)', ylab='Temperature (degC)', ylim=c(-1,35), lwd = 2)
for (i in 2:nx){
lines(seq(1, ncol(temp))*dt/24/3600, temp[i,],
lty = 'dashed',lwd =2)
}
ggplot(avgtemp) +
geom_line(aes(time, epi, col = 'epilimnion')) +
geom_line(aes(time, hyp, col = 'hypolimnion')) +
geom_line(aes(time, tot, col = 'total')) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, stratFlag)) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, thermoclineDep)) +
theme_minimal()
time =  seq(1, ncol(temp), 1)
df <- data.frame(cbind(time, t(temp)) )
colnames(df) <- c("time", as.character(paste0(seq(1,nrow(temp)))))
m.df <- reshape2::melt(df, "time")
ggplot(m.df, aes((time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-2,30),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Temp [degC]')+
scale_y_reverse()
daily_meteo = meteo_all[[1]]
plot(daily_meteo$Ten_Meter_Elevation_Wind_Speed_meterPerSecond)
head(daily_meteo)
## atmo8,spheric boundary conditions
meteo_all <- provide_meteorology(meteofile = 'bc/LakeEnsemblR_meteo_standard.csv',
secchifile = 'bc/light.csv',
windfactor = 0.5)
daily_meteo = meteo_all[[1]]
plot(daily_meteo$Ten_Meter_Elevation_Wind_Speed_meterPerSecond)
#' Created on Thu Aug 19 11:29:34 2021
#'
#' @author: Robert Ladwig
#' @email: rladwig2@wisc.edu
## remove everything from workspace
rm(list = ls())
# set wd to current dir of script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
## colors for plotting
library(tidyverse)
library(RColorBrewer)
library(patchwork)
source('1D_HeatMixing_functions.R')
## lake configurations
zmax = 25 # maximum lake depth
nx = 25 # number of layers we will have
dt = 3600 # 24 hours times 60 min/hour times 60 seconds/min
dx = zmax/nx # spatial step
## area and depth values of our lake
hyps_all <- get_hypsography(hypsofile = 'bc/LakeEnsemblR_bathymetry_standard.csv',
dx = dx, nx = nx)
## here we define our initial profile
u <- initial_profile(initfile = 'bc/obs.txt', nx = nx, dx = dx,
depth = hyps_all[[3]])
## atmo8,spheric boundary conditions
meteo_all <- provide_meteorology(meteofile = 'bc/LakeEnsemblR_meteo_standard.csv',
secchifile = 'bc/light.csv',
windfactor = 0.8)
### EXAMPLE RUNS
# 1 day
temp <- c()
avgtemp <- c()
res <- run_thermalmodel(u = u,
startTime = 1,
endTime = 24*3600,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp)
avgtemp <- rbind(avgtemp, res$average)
# doing another day
for (i in 1:365){
res <-  run_thermalmodel(u = res$temp[, ncol(res$temp)],
startTime = res$endtime,
endTime =  res$endtime + 24*3600,
ice = res$iceflag,
Hi = res$icethickness,
iceT = res$icemovAvg,
supercooled = res$supercooled,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp[,-1])
avgtemp <- rbind(avgtemp, res$average[-1,])
}
plot(seq(1, ncol(temp))*dt/24/3600, temp[1,], col = 'red', type = 'l',
xlab = 'Time (d)', ylab='Temperature (degC)', ylim=c(-1,35), lwd = 2)
for (i in 2:nx){
lines(seq(1, ncol(temp))*dt/24/3600, temp[i,],
lty = 'dashed',lwd =2)
}
ggplot(avgtemp) +
geom_line(aes(time, epi, col = 'epilimnion')) +
geom_line(aes(time, hyp, col = 'hypolimnion')) +
geom_line(aes(time, tot, col = 'total')) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, stratFlag)) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, thermoclineDep)) +
theme_minimal()
time =  seq(1, ncol(temp), 1)
df <- data.frame(cbind(time, t(temp)) )
colnames(df) <- c("time", as.character(paste0(seq(1,nrow(temp)))))
m.df <- reshape2::melt(df, "time")
ggplot(m.df, aes((time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-2,30),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Temp [degC]')+
scale_y_reverse()
#' Created on Thu Aug 19 11:29:34 2021
#'
#' @author: Robert Ladwig
#' @email: rladwig2@wisc.edu
## remove everything from workspace
rm(list = ls())
# set wd to current dir of script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
## colors for plotting
library(tidyverse)
library(RColorBrewer)
library(patchwork)
source('1D_HeatMixing_functions.R')
## lake configurations
zmax = 25 # maximum lake depth
nx = 25 # number of layers we will have
dt = 3600 # 24 hours times 60 min/hour times 60 seconds/min
dx = zmax/nx # spatial step
## area and depth values of our lake
hyps_all <- get_hypsography(hypsofile = 'bc/LakeEnsemblR_bathymetry_standard.csv',
dx = dx, nx = nx)
## here we define our initial profile
u <- initial_profile(initfile = 'bc/obs.txt', nx = nx, dx = dx,
depth = hyps_all[[3]])
## atmo8,spheric boundary conditions
meteo_all <- provide_meteorology(meteofile = 'bc/LakeEnsemblR_meteo_standard.csv',
secchifile = 'bc/light.csv',
windfactor = 0.8)
### EXAMPLE RUNS
# 1 day
temp <- c()
avgtemp <- c()
res <- run_thermalmodel(u = u,
startTime = 1,
endTime = 24*3600,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp)
avgtemp <- rbind(avgtemp, res$average)
# doing another day
for (i in 1:365){
res <-  run_thermalmodel(u = res$temp[, ncol(res$temp)],
startTime = res$endtime,
endTime =  res$endtime + 24*3600,
ice = res$iceflag,
Hi = res$icethickness,
iceT = res$icemovAvg,
supercooled = res$supercooled,
kd_light = NULL,
zmax = zmax,
nx = nx,
dt = dt,
dx = dx,
area = hyps_all[[1]], # area
depth = hyps_all[[2]], # depth
volume = hyps_all[[3]], # volume
daily_meteo = meteo_all[[1]],
secview = meteo_all[[2]],
Cd = 0.0008)
temp <-cbind(temp, res$temp[,-1])
avgtemp <- rbind(avgtemp, res$average[-1,])
}
plot(seq(1, ncol(temp))*dt/24/3600, temp[1,], col = 'red', type = 'l',
xlab = 'Time (d)', ylab='Temperature (degC)', ylim=c(-1,35), lwd = 2)
for (i in 2:nx){
lines(seq(1, ncol(temp))*dt/24/3600, temp[i,],
lty = 'dashed',lwd =2)
}
ggplot(avgtemp) +
geom_line(aes(time, epi, col = 'epilimnion')) +
geom_line(aes(time, hyp, col = 'hypolimnion')) +
geom_line(aes(time, tot, col = 'total')) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, stratFlag)) +
theme_minimal()
ggplot(avgtemp) +
geom_line(aes(time, thermoclineDep)) +
theme_minimal()
time =  seq(1, ncol(temp), 1)
df <- data.frame(cbind(time, t(temp)) )
colnames(df) <- c("time", as.character(paste0(seq(1,nrow(temp)))))
m.df <- reshape2::melt(df, "time")
ggplot(m.df, aes((time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-2,30),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Temp [degC]')+
scale_y_reverse()
ggplot(avgtemp) +
geom_line(aes(time, epi, col = 'epilimnion')) +
geom_line(aes(time, hyp, col = 'hypolimnion')) +
geom_line(aes(time, tot, col = 'total')) +
theme_minimal()
avgtemp$thermoclineDep
meteo_all[[1]$datetime
9*15
5*15

facet_wrap(~ id, ncol =1) +
theme_minimal()
g2 <- ggplot(en.df) +
geom_line(aes(sampledate, n2, col = id))+
geom_point(aes(sampledate, n2, col = id))+
facet_wrap(~ id, ncol =1) +
theme_minimal()
g1 | g2 + plot_layout(guides = 'collect')
library(deSolve)
library(tidyverse)
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dx = x*(alpha - beta*y) # prey
dy = -y*(gamma - delta*x) # predator
return(list(c(dx, dy)))
})
}
# The prey grows at a linear rate (alpha) and gets eaten by the predator at the rate of (beta).
# The predator gains a certain amount vitality by eating the prey at a rate (delta), while dying off at another rate (gamma).
Pars <- c(alpha = 2, beta = .5, gamma = .2, delta = .6)
State <- c(x = 10, y = 10)
Time <- seq(0, 100, by = 1)
out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
ggplot(out) +
geom_path(aes(x = time, y = x), col = 'blue') + #prey
geom_path(aes(x = time, y = y), col = 'red3') + #predator
theme_bw()
ggplot(out) +
geom_path(aes(x = time, y = x, col = 'prey')) + #prey
geom_path(aes(x = time, y = y, col = 'predator')) + #predator
theme_bw()
ggplot(out) +
geom_path(aes(x = time, y = x, col = 'prey')) + #prey
geom_path(aes(x = time, y = y, col = 'predator')) + #predator
theme_bw() +
labs(title = "Lotka-Volterra predator prey model",
subtitle = paste(names(Pars), Pars, sep = " = ", collapse = "; "),
x = "Time", y = "Population density")
# The prey grows at a linear rate (alpha) and gets eaten by the predator at the rate of (beta).
# The predator gains a certain amount vitality by eating the prey at a rate (delta), while dying off at another rate (gamma).
Pars <- c(alpha = 1, beta = 0.2, gamma = 0.5, delta = 0.2)
State <- c(x = 10, y = 10)
Time <- seq(0, 100, by = 1)
out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
ggplot(out) +
geom_path(aes(x = time, y = x, col = 'prey')) + #prey
geom_path(aes(x = time, y = y, col = 'predator')) + #predator
theme_bw() +
labs(title = "Lotka-Volterra predator prey model",
subtitle = paste(names(Pars), Pars, sep = " = ", collapse = "; "),
x = "Time", y = "Population density")
Time <- seq(0, 60, by = 1)
out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
ggplot(out) +
geom_path(aes(x = time, y = x, col = 'prey')) + #prey
geom_path(aes(x = time, y = y, col = 'predator')) + #predator
theme_bw() +
labs(title = "Lotka-Volterra predator prey model",
subtitle = paste(names(Pars), Pars, sep = " = ", collapse = "; "),
x = "Time", y = "Population density")
Time <- seq(0, 40, by = 1)
out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
ggplot(out) +
geom_path(aes(x = time, y = x, col = 'prey')) + #prey
geom_path(aes(x = time, y = y, col = 'predator')) + #predator
theme_bw() +
labs(title = "Lotka-Volterra predator prey model",
subtitle = paste(names(Pars), Pars, sep = " = ", collapse = "; "),
x = "Time", y = "Population density")
ggplot(out) +
geom_path(aes(x = time, y = x, col = 'prey')) + #prey
geom_path(aes(x = time, y = y, col = 'predator')) + #predator
theme_bw() +
labs(title = "Lotka-Volterra predator prey model",
subtitle = paste(names(Pars), Pars, sep = " = ", collapse = "; "),
x = "Time", y = "Population density", fill = '')
ggplot(out) +
geom_path(aes(x = time, y = x, col = 'prey')) + #prey
geom_path(aes(x = time, y = y, col = 'predator')) + #predator
theme_bw() +
labs(title = "Lotka-Volterra predator prey model",
subtitle = paste(names(Pars), Pars, sep = " = ", collapse = "; "),
x = "Time", y = "Population density") +
guides(fill=guide_legend(title=""))
ggplot(out) +
geom_path(aes(x = time, y = x, col = 'prey')) + #prey
geom_path(aes(x = time, y = y, col = 'predator')) + #predator
theme_bw() +
labs(title = "Lotka-Volterra predator prey model",
subtitle = paste(names(Pars), Pars, sep = " = ", collapse = "; "),
x = "Time", y = "Population density") +
guides(fill="")
ggplot(out) +
geom_path(aes(x = time, y = x, col = 'prey')) + #prey
geom_path(aes(x = time, y = y, col = 'predator')) + #predator
theme_bw() +
labs(title = "Lotka-Volterra predator prey model",
subtitle = paste(names(Pars), Pars, sep = " = ", collapse = "; "),
x = "Time", y = "Population density", color = '')
shiny::runApp('Projects/DSI/LotkaVolterra/LotkaVolterra')
runApp('Projects/DSI/LotkaVolterra/LotkaVolterra')
runApp('Projects/DSI/LotkaVolterra/LotkaVolterra')
plot(lynx)
#' Created on Thu Aug 19 11:29:34 2021
#'
#' @author: Robert Ladwig
#' @email: rladwig2@wisc.edu
#'
#' Temperature transport equation as Tt = 1/A K Tzz
#' To run the model you will need (a) one initial water temperature profile,
#' (b) time series data of meteorological drivers: air temperature, wind speed
#' and short-wave radiation, and
#' (c) your lake's hypsography (area over depth), or at least maximum deoth and
#' surface area
#'
#' Diffusion code is based on 12 steps to Navier-Stokes by (c) Lorena A. Barba,
#' Gilbert F. Forsyth 2017.
#' https://lorenabarba.com/blog/cfd-python-12-steps-to-navier-stokes/
#'
#' Eddy diffusivity is estimated from buoyancy frequency according to Hondzo and
#' Stefan (1993) Lake Water Temperature Simulation Model. ASCE
#' https://doi.org/10.1061/(ASCE)0733-9429(1993)119:11(1251)
#'
#' Mixing dynamics code is taken from Herb & Stefan (2004) Temperature
#' stratification and Mixing Dynamics in a Shallow Lake with Submersed
#' Macrophytes. Lake & Reservoir Management
#' https://www.tandfonline.com/doi/pdf/10.1080/07438140409354159
#'
#' Convective overturn algorithm is taken from Saloranta & Andersen (2007)
#' MyLake—A multi-year lake simulation model code suitable for uncertainty
#' and sensitivity analysis simulations. Ecological Modeling
#' https://doi.org/10.1016/j.ecolmodel.2007.03.018
#'
#' Ice formation and growth/decay code is taken from Saloranta & Andersen (2007)
#' MyLake—A multi-year lake simulation model code suitable for uncertainty
#' and sensitivity analysis simulations. Ecological Modeling
#' https://doi.org/10.1016/j.ecolmodel.2007.03.018
## remove everything from workspace
rm(list = ls())
# set wd to current dir of script
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
## colors for plotting
library(tidyverse)
library(RColorBrewer)
library(patchwork)
n <- 60
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors,
rownames(qual_col_pals)))
## lake configurations
zmax = 25 # maximum lake depth
nx = 25 # number of layers we will have
dt = 3600 # 24 hours times 60 min/hour times 60 seconds/min
dx = zmax/nx # spatial step
nyear = 5
nt = nyear * 365* 24 * 60 * 60 # as.double(max(wQ$dt)) # maximum simulation length
## area and depth values of our lake
hyps <- read_csv('bc/LakeEnsemblR_bathymetry_standard.csv')
area = approx(hyps$Depth_meter,hyps$Area_meterSquared,seq(1,nx*dx,
length.out= nx))$y
area[which.min(area)] <- 1e-2
depth = depth= seq(1,nx*dx, length.out = nx)
## function to calculate density from temperature
calc_dens <-function(wtemp){
dens = 999.842594 + (6.793952 * 1e-2 * wtemp) - (9.095290 * 1e-3 *wtemp**2) +
(1.001685 * 1e-4 * wtemp**3) - (1.120083 * 1e-6* wtemp**4) +
(6.536336 * 1e-9 * wtemp**5)
return(dens)
}
## here we define our initial profile
obs <- read_csv('bc/obs.txt')
init.df <- obs %>%
filter(datetime == min(datetime)) %>%
arrange(Depth_meter)
if (max(depth) > max(init.df$Depth_meter)){
init.df <- rbind(init.df, init.df[nrow(init.df),])
init.df$Depth_meter[nrow(init.df)] <- max(depth)
}
u = approx(init.df$Depth_meter, init.df$Water_Temperature_celsius,
seq(0, nx * dx, length.out= nx))$y
rho = calc_dens(u)
## this is our attempt for turbulence closure, estimating eddy diffusivity
eddy_diffusivity <-function(rho, depth, g, rho_0){
buoy = rep(1, (nx)) * 7e-5
for (i in seq(1, nx-1)){#range(0, nx - 1):
buoy[i] = sqrt( abs(rho[i+1] - rho[i]) / (depth[i+1] - depth[i]) * g/rho_0 )
}
buoy[nx] = sqrt( abs(rho[nx-1] - rho[nx]) / abs(depth[nx-1] - depth[nx]) *
g/rho_0 )
low_values_flags = buoy < 7e-5  # Where values are low
buoy[low_values_flags] = 7e-5
kz = 0.00706 *( 3.8 * 1e1)**(0.56) * (buoy)**(-0.43)
return(kz)
}
kz = eddy_diffusivity(rho, depth, 9.81, 998.2) / 86400# 1e4
## atmospheric boundary conditions
## create daily meteorological variables
meteo <- read_csv('bc/LakeEnsemblR_meteo_standard.csv')
# daily_meteo <-  meteo %>%
#   mutate(date = as.Date(datetime)) %>%
#   group_by(date) %>%
#   summarise_all(mean)
daily_meteo <- meteo
daily_meteo$date = daily_meteo$datetime
daily_meteo$Cloud_Cover <- gotmtools::calc_cc(date = as.POSIXct(daily_meteo$date),
airt = daily_meteo$Air_Temperature_celsius,
relh = daily_meteo$Relative_Humidity_percent,
swr = daily_meteo$Shortwave_Radiation_Downwelling_wattPerMeterSquared,
lat = 43, lon = -89.41,
elev = 258)
daily_meteo$dt <- as.POSIXct(daily_meteo$date) - (as.POSIXct(daily_meteo$date)[1]) + 1
daily_meteo$ea <- (daily_meteo$Relative_Humidity_percent * (4.596 * exp((17.27*(daily_meteo$Air_Temperature_celsius))/
(237.3 + (daily_meteo$Air_Temperature_celsius) )))/100)
daily_meteo$ea <- (101.325 * exp(13.3185 * (1 - (373.15 / (daily_meteo$Air_Temperature_celsius + 273.15))) -
1.976 * (1 - (373.15 / (daily_meteo$Air_Temperature_celsius + 273.15)))**2 -
0.6445 * (1 - (373.15 / (daily_meteo$Air_Temperature_celsius + 273.15)))**3 -
0.1229 * (1 - (373.15 / (daily_meteo$Air_Temperature_celsius + 273.15)))**4)) *daily_meteo$Relative_Humidity_percent/100
## linearization of driver data, so model can have dynamic step
Jsw <- approxfun(x = daily_meteo$dt, y = daily_meteo$Shortwave_Radiation_Downwelling_wattPerMeterSquared, method = "linear", rule = 2)
Jlw <- approxfun(x = daily_meteo$dt, y = daily_meteo$Longwave_Radiation_Downwelling_wattPerMeterSquared, method = "linear", rule = 2)
Tair <- approxfun(x = daily_meteo$dt, y = daily_meteo$Air_Temperature_celsius, method = "linear", rule = 2)
ea <- approxfun(x = daily_meteo$dt, y = daily_meteo$ea, method = "linear", rule = 2)
Uw <- approxfun(x = daily_meteo$dt, y = daily_meteo$Ten_Meter_Elevation_Wind_Speed_meterPerSecond, method = "linear", rule = 2)
CC <- approxfun(x = daily_meteo$dt, y = daily_meteo$Cloud_Cover, method = "linear", rule = 2)
Pa <- approxfun(x = daily_meteo$dt, y = daily_meteo$Surface_Level_Barometric_Pressure_pascal, method = "linear", rule = 2)
## additional parameters to run the model
# meteorology
Rl <- 0.03 # 0.3
Acoeff <- 0.6 # coefficient between 0.5 - 0.7
sigma <-  4.9 * 10^(-3) / (24 * 3600) # 11.7 * 10^(-8) # cal / (cm2 d K4) or:
# 4.9 * 10^(-3) # Stefan-Boltzmann constant in [J (m2 d K4)-1]
eps <- 0.97 # emissivity of water
cp <- 4184 # specific heat (J/kg/C)
c1 <- 0.47 # Bowen's coefficient
a <- 7 # constant
c <- 9e4 # empirical constant
g <- 9.81  # gravity (m/s2)
# vertical heating
reflect <- 0.6 # fraction of reflected solar radiation
infra = 0.3 # fraction infrared radiation
kd = 1# 0.2# 1.0 #0.2 # light attenuation coefficient
emissivity = 0.97
sigma = 5.67 * 10^(-8)
p2 = 1
B = 0.61
longwave <- function(emissivity, Jlw){  # longwave radiation into
# the lake
lw = emissivity * Jlw
return(lw)
}
backscattering <- function(emissivity, sigma, Twater){ # backscattering longwave
# radiation from the lake
Twater = Twater + 273.15
back = (eps * sigma * (Twater )^4)
return((-1) * back)
}
sensible <- function(p2, B, Tair, Twater, Uw){ # convection / sensible heat
Twater = Twater + 273.15
Tair = Tair + 273.15
fu = 4.4 + 1.82 * Uw + 0.26 *(Twater - Tair)
sensible <- ( p2 * B * fu * (Twater - Tair))
return((-1) * sensible)
}
latent <- function(Tair, Twater, Uw, p2, pa, ea){ # evaporation / latent heat
Twater = Twater + 273.15
Tair = Tair + 273.15
Pressure = pa / 100
fu = 4.4 + 1.82 * Uw + 0.26 *(Twater - Tair)
fw = 0.61 * (1 + 10^(-6) * Pressure * (4.5 + 6 * 10^(-5) * Twater**2))
ew = fw * 10 * ((0.7859+0.03477* Twater)/(1+0.00412* Twater))
latent = fu * p2 * (ew - ea* 1.33) * 1/5
return((-1) * latent)
}
## plot initial profile
plot( u, seq(0, nx * dx, length.out=(nx)),
ylim = rev(range(seq(0, dx * nx, length.out=(nx)))), xlim = c(0,35),
type ='l');
um <- matrix(NA, ncol = floor(nt/dt), nrow = nx)
kzm <- matrix(NA, ncol = floor(nt/dt), nrow = nx)
n2m <- matrix(NA, ncol = floor(nt/dt), nrow = nx)
Hts <- rep(NA, length = floor(nt/dt))
Swf <- rep(NA, length = floor(nt/dt))
Lwf <- rep(NA, length = floor(nt/dt))
BLwf <- rep(NA, length = floor(nt/dt))
Lf <- rep(NA, length = floor(nt/dt))
Sf <- rep(NA, length = floor(nt/dt))
mix <- rep(NA, length = floor(nt/dt))
therm.z <- rep(NA, length = floor(nt/dt))
mix.z <- rep(NA, length = floor(nt/dt))
Him <- rep(NA, length = floor(nt/dt))
ice = FALSE
Hi= 0
## modeling code for vertical 1D mixing and heat transport
for (n in 1:floor(nt/dt)){  #iterate through time
print(paste0(round(n*100/floor(nt/dt),3),' %'))
un = u # prior temperature values
kz = eddy_diffusivity(calc_dens(un), depth, 9.81, 998.2) / 86400
if (ice){
kzn = rep(1E-6, length = length(kz))
absorp = 0.85
} else {
kzn = kz
absorp = 1-reflect# 0.3
}
kzm[, n] <- kzn
# surface heat flux
Q <- (absorp * Jsw(n * dt) + longwave(emissivity = emissivity, Jlw = Jlw(n * dt)) +
backscattering(emissivity = emissivity, sigma = sigma, Twater = un[1]) +
latent(Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n *dt), p2 = p2, pa = Pa(n*dt), ea=ea(n*dt)) +
sensible(p2 = p2, B = B, Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n * dt)))
# heat addition over depth
H = (1- reflect) * (1- infra) * (Jsw(n * dt))  * #
exp(-(kd ) *seq(dx,nx*dx,length.out=nx))
## (1) DIFFUSION
# surface layer
u[1] = un[1] +
Q * area[1]/(area[1]*dx)*1/(4184 * calc_dens(un[1]) ) *dt +
H[1] * area[1]/(area[1]*dx) * 1/(4184 * calc_dens(un[1]) )* dt
Hts[n] <-  Q *  area[1]/(area[1]*dx)*1/(4181 * calc_dens(un[1]) ) # append(Hts, Q *  area[1]/(area[1]*dx)*1/(4181 * calc_dens(un[1]) ))
Swf[n] <-  absorp * Jsw(n * dt) # append(Swf, 0.3 * Jsw(n * dt))
Lwf[n] <-  longwave(emissivity = emissivity, Jlw = Jlw(n * dt))  #append(Lwf, longwave(emissivity = emissivity, Jlw = Jlw(n * dt)) )
BLwf[n] <-  backscattering(emissivity = emissivity, sigma = sigma, Twater = un[1]) #append(BLwf, backscattering(emissivity = emissivity, sigma = sigma, Twater = un[1]))
Lf[n] <- latent(Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n *dt), p2 = p2, pa = Pa(n*dt), ea=ea(n*dt)) #append(Lf, latent(Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n *dt), p2 = p2, pa = Pa(n*dt), ea=ea(n*dt)) )
Sf[n] <- sensible(p2 = p2, B = B, Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n * dt)) #append(Sf, sensible(p2 = p2, B = B, Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n * dt)))
#
# all other layers in between
for (i in 2:(nx-1)){
u[i] = un[i] +
kzn[i] * dt / dx**2 * (un[i+1] - 2 * un[i] + un[i-1]) +
H[i] * area[i]/(area[i]*dx) * 1/(4184 * calc_dens(un[i]) )* dt
}
# bottom layer
u[nx] = un[nx] +
H[nx] * area[nx]/(area[nx]*dx) * 1/(4181 * calc_dens(un[nx]) ) * dt
## (2) TURBULENT MIXING OF MIXED LAYER
# the mixed layer depth is determined for each time step by comparing kinetic
# energy available from wind and the potential energy required to completely
# mix the water column to a given depth
Zcv <- seq(1, nx) %*% area / sum(area) # center of volume
tau = 1.225 * 0.0013 * Uw(n * dt)^2 # wind shear is air density times shear
if (Uw(n * dt) <= 15) {
c10 = 0.0005 * sqrt(Uw(n * dt))
} else {
c10 = 0.0026
}
shear = sqrt((c10 * calc_dens(un[1]))/1.225) *  Uw(n * dt)# shear velocity
# coefficient times wind velocity squared
KE = shear *  tau * dt # kinetic energy as function of wind
maxdep = 1
for (dep in 1:(nx-1)){
if (dep == 1){
PE = abs(g *  ( seq(1,nx)[dep] - Zcv)  * calc_dens(u[dep]) * dx)
PE = abs(g *   seq(1,nx)[dep] *( seq(1,nx)[dep+1] - Zcv)  * abs(calc_dens(u[dep+1])- calc_dens(u[dep])))
} else {
PEprior = PE
PE = abs(g *  ( seq(1,nx)[dep] - Zcv)  * calc_dens(u[dep]) * dx +
PEprior)
}
if (PE > KE){
maxdep = dep
break
}
maxdep = dep
}
u[1:maxdep] = mean(u[1:maxdep])
mix[n] <- KE/PE #append(mix, KE/PE)
therm.z[n] <- maxdep #append(therm.z, maxdep)
## (3) DENSITY INSTABILITIES
# convective overturn: Convective mixing is induced by an unstable density
# profile. All groups of water layers where the vertical density profile is
# unstable are mixed with the first stable layer below the unstable layer(s)
# (i.e., a layer volume weighed means of temperature and other variables are
# calculated for the mixed water column). This procedure is continued until
# the vertical density profile in the whole water column becomes neutral or stable.
dens_u = calc_dens(u)
diff_dens_u <- (diff(dens_u))
diff_dens_u[abs(diff(dens_u)) < 1e-4] = 0
while (any(diff_dens_u < 0)){
dens_u = calc_dens(u)
for (dep in 1:(nx-1)){
if (dens_u[dep+1] < dens_u[dep] & abs(dens_u[dep+1] - dens_u[dep]) > 1e-4){
u[dep:(dep+1)] = mean(u[dep:(dep+1)])
break
}
}
dens_u = calc_dens(u)
diff_dens_u <- (diff(dens_u))
diff_dens_u[abs(diff(dens_u)) < 1e-4] = 0
}
dens_u_n2 = calc_dens(u)
n2 <- 9.81/mean(calc_dens(u)) * (lead(dens_u_n2) - lag(dens_u_n2))/dx
max.n2 <- ifelse(max(n2, na.rm = T) > 1E-4, which.max(n2) * dx, dx * nx)
mix.z[n] <- max.n2
n2m[, n] <- n2
um[, n] <- u
lines( u, seq(0, dx * nx, length.out=(nx)),
ylim = rev(range(seq(0, dx * nx, length.out=(nx)))), lty = 'dashed');
## (4) ICE FORMATION
# according to Hostetler & Bartlein (1990):
# (1) ice forms when surface water temp <= 1 deg C and melts when > 1 deg
# (2) rate of ice formation/melting is exponential function of ice thickness
# (the thicker the ice, the slower the formation rate, and vice versa)
# (3) heat of fusion is added/subtracted from surface energy balance
# (4) diffusion below ice only happens on molecular level
# (5) with ice, surface absorption of incoming solar radiation increases to 85 %
if (any(u <= 0) == TRUE){
supercooled <- which(u < 0)
initEnergy <- sum((0-u[supercooled])*hyps$Area_meterSquared[supercooled] * dx * 4.18E6)
if (ice != TRUE) {
Hi <- 0.01+(initEnergy/(910*333500))/max(hyps$Area_meterSquared)
} else {
if (Tair(n*dt) > 0){
Tice <- 0
Hi = Hi -max(c(0, dt*(((1-0.4)*Jsw(n * dt))+(backscattering(emissivity = emissivity, sigma = sigma, Twater = un[1]) +
latent(Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n *dt), p2 = p2, pa = Pa(n*dt), ea=ea(n*dt)) +
sensible(p2 = p2, B = B, Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n * dt))) )/(910*333500)))
} else {
Tice <-  ((1/(10 * Hi)) * 0 +  Tair(n*dt)) / (1 + (1/(10 * Hi)))
Hi <- sqrt(Hi**2 + 2 * 2.1/(910 * 333500)* (0 - Tice) * dt)
}
}
ice = TRUE
if (Hi > 0){
u[supercooled] = 0
u[1] = 0
}
Him[n] <- Hi
} else if (ice == TRUE & Hi > 0) {
if (Tair(n*dt) > 0){
Tice <- 0
Hi = Hi -max(c(0, dt*(((1-0.2)*Jsw(n * dt))+(backscattering(emissivity = emissivity, sigma = sigma, Twater = un[1]) +
latent(Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n *dt), p2 = p2, pa = Pa(n*dt), ea=ea(n*dt)) +
sensible(p2 = p2, B = B, Tair = Tair(n*dt), Twater = un[1], Uw = Uw(n * dt))) )/(910*333500)))
} else {
Tice <-  ((1/(10 * Hi)) * 0 +  Tair(n*dt)) / (1 + (1/(10 * Hi)))
Hi <- sqrt(Hi**2 + 2 * 2.1/(910 * 333500)* (0 - Tice) * dt)
}
u[supercooled] = 0
u[1] = 0
Him[n] <- Hi
} else if (ice == TRUE & Hi <= 0){
ice = FALSE
}
}
## contour plot of water temperature
time =  seq(1, ncol(um))*dt/24/3600
df <- data.frame(cbind(time, t(um)) )
colnames(df) <- c("time", as.character(paste0(seq(1,nrow(um)))))
m.df <- reshape2::melt(df, "time")
m.df$time <- time
df.kz <- data.frame(cbind(time, t(kzm)) )
colnames(df.kz) <- c("time", as.character(paste0(seq(1,nrow(kzm)))))
m.df.kz <- reshape2::melt(df.kz, "time")
m.df.kz$time <- time
df.n2 <- data.frame(cbind(time, t(n2m)) )
colnames(df.n2) <- c("time", as.character(paste0(seq(1,nrow(n2m)))))
m.df.n2 <- reshape2::melt(df.n2, "time")
m.df.n2$time <- time
g1 <- ggplot(m.df, aes(as.numeric(time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-2,35),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Temp [degC]')+
scale_y_reverse()
g2 <- ggplot(m.df.kz, aes(as.numeric(time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(#limits = c(-20,35),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Diffusion [m2/s]')+
scale_y_reverse()
g3 <- ggplot(m.df.n2, aes(as.numeric(time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(#limits = c(-20,35),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'N2 [s-2]')+
scale_y_reverse()
g <- g1 / g2 / g3; g
ggsave(filename = 'heatmap.png',plot = g, width = 15, height = 8, units = 'in')
g1 <- ggplot(m.df, aes(as.numeric(time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(limits = c(-2,35),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Temp [degC]')+
scale_y_reverse()
g2 <- ggplot(m.df.kz, aes(as.numeric(time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(#limits = c(-20,35),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'Diffusion [m2/s]')+
scale_y_reverse()
g3 <- ggplot(m.df.n2, aes(as.numeric(time), as.numeric(variable))) +
geom_raster(aes(fill = as.numeric(value)), interpolate = TRUE) +
scale_fill_gradientn(#limits = c(-20,35),
colours = rev(RColorBrewer::brewer.pal(11, 'Spectral')))+
theme_minimal()  +xlab('Time') +
ylab('Depth') +
labs(fill = 'N2 [s-2]')+
scale_y_reverse()
g <- g1 / g2 / g3
ggsave(filename = 'heatmap.png',plot = g, width = 15, height = 8, units = 'in')
str(df)
str(df.n2)
